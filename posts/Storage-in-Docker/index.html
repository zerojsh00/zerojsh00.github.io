<!DOCTYPE html><html lang="ko" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="(K8S) 도커의 스토리지(Storage in Docker)" /><meta name="author" content="simon sanghyeon" /><meta property="og:locale" content="ko" /><meta name="description" content="이 글은 Mumshad Mannambeth가 강의한 Udemy의 Certified Kubernetes Administrator (CKA) with Practice Tests 강의 커리큘럼을 토대로 공부한 내용을 정리하였음을 밝힙니다." /><meta property="og:description" content="이 글은 Mumshad Mannambeth가 강의한 Udemy의 Certified Kubernetes Administrator (CKA) with Practice Tests 강의 커리큘럼을 토대로 공부한 내용을 정리하였음을 밝힙니다." /><link rel="canonical" href="https://zerojsh00.github.io/posts/Storage-in-Docker/" /><meta property="og:url" content="https://zerojsh00.github.io/posts/Storage-in-Docker/" /><meta property="og:site_name" content="Simon’s Research Center" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-09-03T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="(K8S) 도커의 스토리지(Storage in Docker)" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@simon sanghyeon" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"simon sanghyeon"},"dateModified":"2022-10-02T22:02:15+09:00","datePublished":"2022-09-03T00:00:00+09:00","description":"이 글은 Mumshad Mannambeth가 강의한 Udemy의 Certified Kubernetes Administrator (CKA) with Practice Tests 강의 커리큘럼을 토대로 공부한 내용을 정리하였음을 밝힙니다.","headline":"(K8S) 도커의 스토리지(Storage in Docker)","mainEntityOfPage":{"@type":"WebPage","@id":"https://zerojsh00.github.io/posts/Storage-in-Docker/"},"url":"https://zerojsh00.github.io/posts/Storage-in-Docker/"}</script><title>(K8S) 도커의 스토리지(Storage in Docker) | Simon's Research Center</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Simon's Research Center"><meta name="application-name" content="Simon's Research Center"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><meta name="google-site-verification" content="J_a4XJ2oefe52p6EYvjTFdh9LW5Yc5RyGg1HpQOjWaA" /><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Simon's Research Center</a></div><div class="site-subtitle font-italic">성장하는 연구원의 공책</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/zerojsh00" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['zerojsh00','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>(K8S) 도커의 스토리지(Storage in Docker)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>(K8S) 도커의 스토리지(Storage in Docker)</h1><div class="post-meta text-muted"><div> By <em> Sanghyeon </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1662130800" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-09-03 </em> </span> <span> Updated <em class="timeago" data-ts="1664715735" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-10-02 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2459 words"> <em>13 min</em> read</span></div></div></div><div class="post-content"><p>이 글은 Mumshad Mannambeth가 강의한 Udemy의 Certified Kubernetes Administrator (CKA) with Practice Tests 강의 커리큘럼을 토대로 공부한 내용을 정리하였음을 밝힙니다.</p><hr /><p>이번에는 <code class="language-plaintext highlighter-rouge">file system</code>과 <code class="language-plaintext highlighter-rouge">docker storage driver</code>에 대해서 간략히 살펴보고자 한다. 즉, 도커가 데이터를 어떻게 저장하는지, 그리고 컨테이너의 파일 시스템을 어떻게 관리하는지를 살펴본다.</p><p>도커가 로컬 파일 시스템에서 데이터를 어떻게 저장하는지부터 살펴보자. 도커를 설치하면, 도커는 <code class="language-plaintext highlighter-rouge">/var/lib/docker</code> 폴더 경로를 생성한다. 이 경로 밑에는 <code class="language-plaintext highlighter-rouge">aufs</code>, <code class="language-plaintext highlighter-rouge">containers</code>, <code class="language-plaintext highlighter-rouge">image</code>, <code class="language-plaintext highlighter-rouge">volume</code> 등 다양한 폴더들이 생성된다. 이곳이 default로 도커가 데이터를 저장하는 경로가 된다. 예컨대, 컨테이너와 관련된 모든 파일들은 containers 폴더, 이미지와 관련된 모든 파일들은 image 폴더에, 그리고 도커 컨테이너에 의해서 만들어진 볼륨들은 volume 폴더에 저장된다.</p><hr /><h1 id="recap--도커의-레이어-구조">Recap : 도커의 레이어 구조</h1><p>그런데, 도커는 어떻게 이미지와 컨테이너의 파일들을 저장할까? 이를 알기 위해서는 <code class="language-plaintext highlighter-rouge">도커의 레이어 구조</code>를 알아야 한다.</p><p>아래와 같은 Dockerfile이 있다고 해보자.</p><div class="language-docker highlighter-rouge"><div class="code-header"> <span data-label-text="Docker"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">FROM</span><span class="s"> Ubuntu</span>

<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nt">-y</span> <span class="nb">install </span>python

<span class="k">RUN </span>pip <span class="nb">install </span>flask flask-mysql

<span class="k">COPY</span><span class="s"> . /opt/source-code</span>

<span class="k">ENTRYPOINT</span><span class="s"> FLASK_APP=/opt/source-code/app.py flask run</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">docekr build Dockerfile -t simon/my-custom-app</code></p><p>또 위와 매우 유사한, 아래와 같이 Dockerfile2가 있다고 해보자.</p><div class="language-docker highlighter-rouge"><div class="code-header"> <span data-label-text="Docker"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">FROM</span><span class="s"> Ubuntu</span>

<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nt">-y</span> <span class="nb">install </span>python

<span class="k">RUN </span>pip <span class="nb">install </span>flask flask-mysql

<span class="k">COPY</span><span class="s"> app2.py /opt/source-code</span>

<span class="k">ENTRYPOINT</span><span class="s"> FLASK_APP=/opt/source-code/app2.py flask run</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">docekr build Dockerfile2 -t simon/my-custom-app-2</code></p><p>Dockerfile2는 Dockerfile에서 일부만 변경되었다. 이 경우 Dockerfile2를 위해서 120MB가 되는 우분투 이미지(첫 줄)와 300MB 정도 되는 apt package(두 번째 줄) 등을 모두 다시 받아야 한다면 매우 비효율적이다.</p><p>따라서 도커는 <code class="language-plaintext highlighter-rouge">레이어 구조</code>를 사용한다. 즉, Dockerfile과 Dockerfile2 모두 세 번째 줄까지는 동일한 내용이므로, 캐시로부터 동일한 레이어로 공유한다. 그리고 Dockerfile2에서 변경 사항이 생긴 네 번째 줄과 마지막 줄만 새롭게 레이어로 생성한다. 이러한 방식으로 도커는 이미지를 더욱 빨리 빌드할 수 있으며, 디스크 공간도 효율적으로 사용할 수 있는 것이다. 이를 그림으로 나타내면 아래와 같다.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 500 500'%3E%3C/svg%3E" data-src="/assets/img/2022-09-03-Storage in Docker/fig01.png" alt="fig01" width="500" height="500" data-proofer-ignore></p><h2 id="이미지-레이어image-layer와-컨테이너-레이어container-layer"><span class="mr-2">이미지 레이어(Image Layer)와 컨테이너 레이어(Container Layer)</span><a href="#이미지-레이어image-layer와-컨테이너-레이어container-layer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>다시 Dockerfile을 살펴보자. <code class="language-plaintext highlighter-rouge">docekr build Dockerfile -t simon/my-custom-app</code> 명령어를 통해서 Dockerfile을 빌드하면, <code class="language-plaintext highlighter-rouge">이미지 레이어(Image Layer)</code>라는 레이어가 다음과 같이 생성된다. 이 레이어들은 모두 <code class="language-plaintext highlighter-rouge">read only</code> 레이어이므로, 변경될 수 없으며, 부득이 변경하고자 한다면 Dockerfile을 변경 후 다시 빌드하는 수밖에 없다.</p><ul><li><strong>Layer 5</strong> : Update Entrypoint with “flask” command<li><strong>Layer 4</strong> : Source code<li><strong>Layer 3</strong> : Changes in pip package<li><strong>Layer 2</strong> : Changes in apt package<li><strong>Layer 1</strong> : Base Ubuntu Layer</ul><p>이후, <code class="language-plaintext highlighter-rouge">docker run simon/my-custom-app</code> 명령으로 이 Dockerfile을 실행(run)하면 image layer 위에 추가로 <code class="language-plaintext highlighter-rouge">컨테이너 레이어(Container Layer)</code>라는 레이어가 하나 더 생긴다. 이는 <code class="language-plaintext highlighter-rouge">read &amp; write</code> 레이어로, write 기능이 있다. 즉, 로그 데이터라든지, temporary 파일이라든지, 혹은 사용자들에 의해서 변경되는 내용들 등 컨테이너에 의해서 생성되는 데이터들이 저장되는 데 사용되는 레이어다.</p><ul><li><strong>Layer 6</strong>: Container Layer</ul><p>이러한 컨테이너 레이어는 컨테이너가 살아있을 때에만 존재하며, 컨테이너 실행이 중단되면 해당 레이어와 이곳에 저장되어 있던 변경 사항 데이터들도 사라진다.</p><hr /><h1 id="copy-on-wirte-메커니즘">Copy-on-Wirte 메커니즘</h1><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 500 500'%3E%3C/svg%3E" data-src="/assets/img/2022-09-03-Storage in Docker/fig02.png" alt="fig02" width="500" height="500" data-proofer-ignore></p><p>위와 같은 상황에서 read only인 이미지 레이어에 있는 app.py 파일에 변경 사항이 생기면 어떻게 해야 할까? 동일한 이미지 레이어는 해당 레이어를 사용하는 여러 컨테이너들에서 공유되기 때문에, read only인 이미지 레이어의 app.py는 변경이 불가능할까?</p><p><code class="language-plaintext highlighter-rouge">Copy-on-Write(CoW) 메커니즘</code>을 사용하면 변경할 수 있다. CoW 메커니즘은 read only 레이어에 있는 파일에 변경 사항이 생길 때 이를 처리하는 가장 쉬운 방법이다.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 500 500'%3E%3C/svg%3E" data-src="/assets/img/2022-09-03-Storage in Docker/fig03.png" alt="fig03" width="500" height="500" data-proofer-ignore></p><p>위와 같이, 우선적으로 read only인 이미지 레이어에 있는 파일을 write가 가능한 컨테이너 레이어에 복사한다. 그 후, write가 가능한 레이어에 복사된 파일에 대해서 변경 사항을 적용한다. 즉, 이미지 레이어에 있는 파일 자체가 변경되는 것은 아닌 셈이다. 이때 컨테이너는 변경 사항이 적용된 레이어의 파일만 볼 수 있을 뿐, 이미지 레이어에 존재하는 파일은 볼 수 없다.</p><p>그러나 이러한 방식에는 문제가 있다. 컨테이너를 삭제하면, 컨테이너 레이어도 함께 삭제되기 때문이다. 즉, 변경 사항이 반영된 app.py 파일도 함께 사라지게 된다. 따라서 영구적으로 데이터를 관리하는 방식이 필요하다.</p><hr /><h1 id="cow-메커니즘의-한계를-보완하는-volume-mount">CoW 메커니즘의 한계를 보완하는 Volume Mount</h1><p>CoW의 문제를 해결하는 방법으로 <code class="language-plaintext highlighter-rouge">volume mount</code>를 통해 컨테이너에서 persistent volume을 사용할 수 있다.</p><p>우선, <code class="language-plaintext highlighter-rouge">docker volume create {볼륨_이름}</code> 명령을 통해서 볼륨을 생성한다. 이는 <code class="language-plaintext highlighter-rouge">/var/lib/docker/volumes/{볼륨_이름}</code> 경로를 만들어 낸다. 이후, <code class="language-plaintext highlighter-rouge">docker run -v {볼륨_이름}:{컨테이너_내의_경로} {이미지_이름}</code>명령으로 이미지를 실행시키면, persistent volume이 마운트된다.</p><p>예를 들어, mysql 이미지를 data_volume이라는 이름의 볼륨에 마운트 하고자 한다면, <code class="language-plaintext highlighter-rouge">docker volume create data_volume</code> 명령으로 data_volume을 생성한 후, 컨테이너 내에서 mysql의 데이터가 저장되는 default 위치인 <code class="language-plaintext highlighter-rouge">/var/lib/mysql</code> 경로를 입력하여 <code class="language-plaintext highlighter-rouge">docker run -v data_volume:/var/lib/mysql mysql</code> 명령으로 mysql 이미지를 실행한다. 이를 도식으로 표현하면 다음과 같다.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 500 500'%3E%3C/svg%3E" data-src="/assets/img/2022-09-03-Storage in Docker/fig04.png" alt="fig04" width="500" height="500" data-proofer-ignore></p><p>이처럼 volume mount를 활용하면 컨테이너를 삭제해도 데이터가 호스트에 보존될 수 있다.</p><p>한편, <code class="language-plaintext highlighter-rouge">docker volume create {볼륨_이름}</code> 명령으로 볼륨을 생성하지 않고서, <code class="language-plaintext highlighter-rouge">docker run -v</code> 명령으로 volume mount를 적용한다면 어떻게 될까? 이 경우, 도커에 의해 <code class="language-plaintext highlighter-rouge">-v</code> 옵션 이후에 입력한 볼륨 이름으로 볼륨이 자동으로 생성된 후 마운트 된다. 정리하자면, volume mount를 통해 도커의 볼륨 디렉토리와 컨테이너를 마운트 할 수 있는 것이다.</p><hr /><h1 id="bind-mount">Bind Mount</h1><p>만약, 도커 호스트 내 어떤 곳에 이미 데이터가 존재한다면, 해당 데이터의 경로를 컨테이너에 <code class="language-plaintext highlighter-rouge">bind mount</code> 할 수 있다. 이 경우, <code class="language-plaintext highlighter-rouge">docker run -v {데이터가 존재하는 절대 경로}:{컨테이너_내의_경로} {이미지 이름}</code> 명령을 실행하여 bind mount 할 수 있다. 정리하자면, bind mount를 통해 도커 호스트 내 어떤 경로든 컨테이너와 마운트 할 수 있는 것이다.</p><hr /><h1 id="storage-driver">Storage Driver</h1><p>지금까지 살펴보았듯, 컨테이너를 실행할 때 write가 가능한 컨테이너 레이어를 만들고, 이미지 레이어로부터 파일을 복사하는 등, 스토리지와 관련한 일련의 과정을 수행하는 주체를 <code class="language-plaintext highlighter-rouge">storage driver</code>라고 부른다. storage driver는 <code class="language-plaintext highlighter-rouge">AUFS</code>, <code class="language-plaintext highlighter-rouge">ZFS</code>, <code class="language-plaintext highlighter-rouge">BTRFS</code>, <code class="language-plaintext highlighter-rouge">Device Mapper</code>, <code class="language-plaintext highlighter-rouge">Overlay</code>, <code class="language-plaintext highlighter-rouge">Overlay2</code> 등이 있으며, OS에 따라서 어떤 storage driver를 사용할지가 자동으로 결정된다. 예를 들어, 우분투의 경우 default로 AUFS를 사용한다.</p><hr /><h1 id="volume-driver-plugins-in-docker">Volume Driver Plugins in Docker</h1><p>앞서, 컨테이너나 이미지의 스토리지를 관리하는 <code class="language-plaintext highlighter-rouge">storage drivers</code>를 살펴보았다. 또한 스토리지를 영구적으로 사용하기 위해서는 볼륨을 생성해서 마운트해야 하는 것 또한 살펴보았다.</p><p>이때, 볼륨은 storage driver에 의해서 관리되지 않는다. 볼륨은 <code class="language-plaintext highlighter-rouge">volume driver</code>에 의해서 관리된다. volume driver의 default volume driver로는 <code class="language-plaintext highlighter-rouge">Local</code>이 있다. Local 볼륨은 도커 호스트에서 볼륨을 생성하고, <code class="language-plaintext highlighter-rouge">/var/lib/docker/volumes</code> 경로에 데이터를 저장하도록 관리하는 역할을 수행한다. 이외에도 서드파티 솔루션에 마운트가 가능하도록 지원해주는 volume driver의 종류는 매우 다양한데, <code class="language-plaintext highlighter-rouge">Azure File Storage</code>, <code class="language-plaintext highlighter-rouge">Convoy</code>, <code class="language-plaintext highlighter-rouge">DigitalOcean Block Storage</code>, <code class="language-plaintext highlighter-rouge">Flocker</code>, <code class="language-plaintext highlighter-rouge">gce-docker</code>, <code class="language-plaintext highlighter-rouge">GlusterFS</code>, <code class="language-plaintext highlighter-rouge">NetApp</code>, <code class="language-plaintext highlighter-rouge">RexRay</code>, <code class="language-plaintext highlighter-rouge">Portworx</code>, <code class="language-plaintext highlighter-rouge">VMware vSphere Storage</code> 등이 있다.</p><p><code class="language-plaintext highlighter-rouge">docker run --volume-driver {volume_driver_이름}</code> 명령으로 원하는 volume driver를 지정하여 마운트해 사용할 수 있다.</p><hr /><h1 id="참고-문헌">참고 문헌</h1><p>[1] <code class="language-plaintext highlighter-rouge">Mumshad Mannambeth의 강의</code> : <a href="https://www.udemy.com/course/certified-kubernetes-administrator-with-practice-tests/">Certified Kubernetes Administrator (CKA) with Practice Tests</a><br /> [2] <code class="language-plaintext highlighter-rouge">시작하세요! 도커/쿠버네티스 (용찬호 지음)</code> : <a href="http://www.yes24.com/Product/Goods/84927385">시작하세요! 도커/쿠버네티스</a><br /></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/kubernetes/'>Kubernetes</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/kubernetes/" class="post-tag no-text-decoration" >Kubernetes</a> <a href="/tags/k8s/" class="post-tag no-text-decoration" >K8S</a> <a href="/tags/storage/" class="post-tag no-text-decoration" >Storage</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%28K8S%29+%EB%8F%84%EC%BB%A4%EC%9D%98+%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%28Storage+in+Docker%29+-+Simon%27s+Research+Center&url=https%3A%2F%2Fzerojsh00.github.io%2Fposts%2FStorage-in-Docker%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%28K8S%29+%EB%8F%84%EC%BB%A4%EC%9D%98+%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%28Storage+in+Docker%29+-+Simon%27s+Research+Center&u=https%3A%2F%2Fzerojsh00.github.io%2Fposts%2FStorage-in-Docker%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fzerojsh00.github.io%2Fposts%2FStorage-in-Docker%2F&text=%28K8S%29+%EB%8F%84%EC%BB%A4%EC%9D%98+%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%28Storage+in+Docker%29+-+Simon%27s+Research+Center" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div><script src="https://utteranc.es/client.js" repo="zerojsh00/zerojsh00.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async> </script></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Network-Policy/">(K8S) 네트워크 정책(Network Policy) 기초 개념</a><li><a href="/posts/CNI-Weave/">(K8S) CNI Weave의 기초 개념</a><li><a href="/posts/Container-Networking-Interface/">(K8S) 네트워크 기초 정리 - CNI</a><li><a href="/posts/Storage-in-Docker/">(K8S) 도커의 스토리지(Storage in Docker)</a><li><a href="/posts/Security-Context/">(K8S) Security Context</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/k8s/">K8S</a> <a class="post-tag" href="/tags/kubernetes/">Kubernetes</a> <a class="post-tag" href="/tags/paper-review/">Paper Review</a> <a class="post-tag" href="/tags/security/">Security</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/speech-ai/">Speech AI</a> <a class="post-tag" href="/tags/scheduling/">Scheduling</a> <a class="post-tag" href="/tags/nlp/">NLP</a> <a class="post-tag" href="/tags/storage/">Storage</a> <a class="post-tag" href="/tags/asr/">ASR</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Volumes/"><div class="card-body"> <em class="timeago small" data-ts="1662217200" > 2022-09-04 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>(K8S) 쿠버네티스의 볼륨(Volumes)</h3><div class="text-muted small"><p> 이 글은 Mumshad Mannambeth가 강의한 Udemy의 Certified Kubernetes Administrator (CKA) with Practice Tests 강의 커리큘럼을 토대로 공부한 내용을 정리하였음을 밝힙니다. 도커 컨테이너는 기본적으로 일시적(transient)이다. 즉, 필요한 경우 실행되었다가 이후 종료되며 컨테이너가 ...</p></div></div></a></div><div class="card"> <a href="/posts/Persistent-Volumes/"><div class="card-body"> <em class="timeago small" data-ts="1662303600" > 2022-09-05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>(K8S) 퍼시스턴트 볼륨(Persistent Volume)</h3><div class="text-muted small"><p> 이 글은 Mumshad Mannambeth가 강의한 Udemy의 Certified Kubernetes Administrator (CKA) with Practice Tests 강의 커리큘럼을 토대로 공부한 내용을 정리하였음을 밝힙니다. YAML을 이용한 볼륨 마운트의 문제 앞서 쿠버네티스에서 파드 정의 YAML 파일을 이용해서 볼륨의 정보를 직접 입...</p></div></div></a></div><div class="card"> <a href="/posts/Persistent-Volume-Claims/"><div class="card-body"> <em class="timeago small" data-ts="1662390000" > 2022-09-06 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>(K8S) 퍼시스턴트 볼륨 클레임(Persistent Volume Claim)</h3><div class="text-muted small"><p> 이 글은 Mumshad Mannambeth가 강의한 Udemy의 Certified Kubernetes Administrator (CKA) with Practice Tests 강의 커리큘럼을 토대로 공부한 내용을 정리하였음을 밝힙니다. Recap : 퍼시스턴트 볼륨과 퍼시스턴트 볼륨 클레임 앞서 정리한 글에서 퍼시스턴트 볼륨(PV)과 퍼시스턴트 볼륨...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Network-Policy/" class="btn btn-outline-primary" prompt="Older"><p>(K8S) 네트워크 정책(Network Policy) 기초 개념</p></a> <a href="/posts/Volumes/" class="btn btn-outline-primary" prompt="Newer"><p>(K8S) 쿠버네티스의 볼륨(Volumes)</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/zerojsh00">Sanghyeon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/k8s/">K8S</a> <a class="post-tag" href="/tags/kubernetes/">Kubernetes</a> <a class="post-tag" href="/tags/paper-review/">Paper Review</a> <a class="post-tag" href="/tags/security/">Security</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/speech-ai/">Speech AI</a> <a class="post-tag" href="/tags/scheduling/">Scheduling</a> <a class="post-tag" href="/tags/nlp/">NLP</a> <a class="post-tag" href="/tags/storage/">Storage</a> <a class="post-tag" href="/tags/asr/">ASR</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
